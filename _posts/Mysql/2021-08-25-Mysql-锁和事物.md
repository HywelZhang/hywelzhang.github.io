---
Author: Hywel
layout: post
title: Mysql事物和锁关系
description: 事物和锁的实现关系
date: 2022-08-25
categories: Mysql
---

[TOC]

## 事物
### 本地事务

#### 事物隔离问题：
1. 脏读
2. 不可重复读
3. 幻读

#### 锁分类：
**1. 写锁（Write Lock，也叫作排他锁，eXclusive Lock，简写为 X-Lock）**：如果数据有加写锁，就只有持有写锁的事务才能对数据进行写入操作，数据加持着写锁时，其他事务不能写入数据，也不能施加读锁。

**2. 读锁（Read Lock，也叫作共享锁，Shared Lock，简写为 S-Lock）**：多个事务可以对同一个数据添加多个读锁，数据被加上读锁后就不能再被加上写锁，所以其他事务不能对该数据进行写入，但仍然可以读取。对于持有读锁的事务，如果该数据只有它自己一个事务加了读锁，允许直接将其升级为写锁，然后写入数据。

**3. 范围锁（Range Lock）**：对于某个范围直接加排他锁，在这个范围内的数据不能被写入。如下语句是典型的加范围锁的例子：

#### 数据库隔离级别对应

| 隔离级别 | 对应问题               | 实现方式                                                     | 备注       |
| -------- | ---------------------- | ------------------------------------------------------------ | ---------- |
| 串行化   | 性能低                 | 读锁、写锁、范围锁。对事务所有读、写的数据全都加上读锁、写锁和范围锁即可做到可串行化（2PL两阶段锁进行处理） |            |
| 可重复读 | 幻读                   | 读锁、写锁。可重复读对事务所涉及的数据加读锁和写锁，且一直持有至事务结束，但不再加范围锁。 | innodb默认 |
| 读已提交 | 不可重复读、幻读       | 读已提交对事务涉及的数据加的写锁会一直持续到事务结束，但加的读锁在查询操作完成后就马上会释放 |            |
| 读未提交 | 脏读、不可重复读、幻读 | 读未提交对事务涉及的数据只加写锁，会一直持续到事务结束，但完全不加读锁 |            |

#### MVCC多版本并发控制
多版本并发控制（Multi-Version Concurrency Control，MVCC）：MVCC 是一种读取优化策略，它的“无锁”是特指读取时不需要加锁。MVCC 的基本思路是对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老版本共存，以此达到读取时可以完全不加锁的目的。你不妨将版本理解为数据库中每一行记录都存在两个看不见的字段：CREATE_VERSION 和 DELETE_VERSION。这两个字段记录的值都是事务 ID，事务 ID 是一个全局严格递增的数值，然后根据以下规则写入数据。

插入数据时：CREATE_VERSION 记录插入数据的事务 ID，DELETE_VERSION 为空。
删除数据时：DELETE_VERSION 记录删除数据的事务 ID，CREATE_VERSION 为空。
修改数据时：将修改数据视为“删除旧数据，插入新数据”的组合，即先将原有数据复制一份，原有数据的 DELETE_VERSION 记录修改数据的事务 ID，CREATE_VERSION 为空。复制出来的新数据的 CREATE_VERSION 记录修改数据的事务 ID，DELETE_VERSION 为空。此时，如有另外一个事务要读取这些发生了变化的数据，将根据隔离级别来决定到底应该读取哪个版本的数据。

隔离级别是可重复读：总是读取 CREATE_VERSION 小于或等于当前事务 ID 的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务 ID 最大）的。
隔离级别是读已提交：总是取最新的版本即可，即最近被 Commit 的那个版本的数据记录。
另外两个隔离级别都没有必要用到 MVCC，因为读未提交直接修改原始数据即可，其他事务查看数据的时候立刻可以看到，根本无须版本字段。可串行化本来的语义就是要阻塞其他事务的读取操作，而 MVCC 是做读取时无锁优化的，自然就不会放到一起用。

MVCC 是只针对“读+写”场景的优化，如果是两个事务同时修改数据，即“写+写”的情况，那就没有多少优化的空间了，此时加锁几乎是唯一可行的解决方案，稍微有点讨论余地的是加锁的策略是“乐观加锁”（Optimistic Locking）还是“悲观加锁”（Pessimistic Locking）。前面笔者介绍的加锁都属于悲观加锁策略，即认为如果不先做加锁再访问数据，就肯定会出现问题。相对地，乐观加锁策略认为事务之间数据存在竞争是偶然情况，没有竞争才是普遍情况，这样就不应该在一开始就加锁，而是应当在出现竞争时再找补救措施。这种思路被称为“乐观并发控制”（Optimistic Concurrency Control，OCC），囿于篇幅与主题的原因，就不再展开了，不过笔者提醒一句，没有必要迷信什么乐观锁要比悲观锁更快的说法，这纯粹看竞争的剧烈程度，如果竞争剧烈的话，乐观锁反而更慢。

### 全局事务
#### “两段式提交”（2 Phase Commit，2PC）协议
**准备阶段：** 又叫作投票阶段，在这一阶段，协调者询问事务的所有参与者是否准备好提交，参与者如果已经准备好提交则回复 Prepared，否则回复 Non-Prepared。这里所说的准备操作跟人类语言中通常理解的准备并不相同，对于数据库来说，准备操作是在重做日志中记录全部事务提交操作所要做的内容，它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已，这意味着在做完数据持久化后并不立即释放隔离性，即仍继续持有锁，维持数据对其他非事务内观察者的隔离状态。
**提交阶段：** 又叫作执行阶段，协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，在此操作完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；否则，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作。对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条 Commit Record 而已，通常能够快速完成，只有收到 Abort 指令时，才需要根据回滚日志清理已提交的数据，这可能是相对重负载操作。

